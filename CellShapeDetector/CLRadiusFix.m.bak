
function [radius,CLb,slice_binary,avg_radius]=CLRadiusFix(xf,yf,zf,CL)
%%%% Finding the radius %%%%
%%%% GOAL: given a mapping U,V find the radius of the mapping as a function
%%%% of u and of v.
%%%% We have a center line as a function of u and of v and a surface as a
%%%% function of u and of v.


%%%% The current code outputs CLb as a new center line; in the final code
%%%% this should probably be changed to CL (CLb was used for ease of
%%%% testing)

%%%% This code first interpolates CL by a specific factor N (N points
%%%% are added between each pair of points in CL.  The interpolated line
%%%% is stored in CLprime.

%%%% Then the points on the surface of the cell are partitioned into
%%%% slices.  When numberslices == length(CL), each slice corresponds to one 
%%%% point in CL as well as the following sequence of interpolated points,
%%%% ending right before the next point in CL.  Given the set X_i of points
%%%% on CL, S_i is defined to consist of the set of
%%%% points p on the surface for which there exists a point q_p in X_i
%%%% such that dist(p,q_p) <= dist(p,z) for any point z in CL.

%%%% radius is the final output radius of the cell at each point on the 
%%%% surface (radius is a function of the parameters of the surface)

sizes = size(xf);

CLb = CL;
N = 5; %%%%% number of points added between points in CL in the interpolation
SurfPointsvect = cat(2, xf(:), yf(:), zf(:));
CLprime = cat(2,interp(double(CL(:,1)),N),interp(double(CL(:,2)),N),interp(double(CL(:,3)),N));

[distances,indices] = pdist2(CLprime,SurfPointsvect,'minkowski',2,'Smallest',1); 

radius = double(reshape(distances, sizes(1), sizes(2)));

indices1 = double(reshape(indices, sizes(1), sizes(2)));

numberslices = length(CL); 

slice = cell(1, numberslices);
slice_binary = cell(1, numberslices);
xslice = cell(1, numberslices);
yslice = cell(1, numberslices);
zslice = cell(1, numberslices);
avg_radius = zeros(1, numberslices);

divisor = ceil((max(indices)- min(indices))/numberslices);


maxcount = 0;

%%% Partitions the surface into slices
for i=1:1:(numberslices)
    
    mincount = maxcount;
    maxcount = mincount + divisor;
    
    slice_binary{i} = +((indices1 > mincount) & (indices1 <= maxcount));
    %%%% The plus converts slice_binary{i} from logical to a numerical type %%%%
    %%%% This allows only surface points in the appropriate
    %%%% slice to be collected.
    
    xslice{i} = xf .* slice_binary{i};
    yslice{i} = yf .* slice_binary{i};
    zslice{i} = zf .* slice_binary{i};
    mindistance = inf;
    
    slice{i} = cat(2, xslice{i}(xslice{i}~= 0), yslice{i}(yslice{i}~= 0), zslice{i}(zslice{i}~= 0));
   
    %%% Finding a new center line
    
    %%% This for loop is iterated N times (equal to the number of points
    %%% added between points of CL in the interpolation.
    for j = mincount+1:1:maxcount
        totaldistance = sum(pdist2(CLprime(j,:),slice{i}));
         %%%%%THE FOLLOWING CODE ONLY WORKS IF numberslices == length(CL)
        if totaldistance < mindistance
            mindistance = totaldistance;
            CLb(i,:) = CLprime(j,:);
        end
    end
    avg_radius(i) = totaldistance/sum(sum(slice_binary{i}));
end


%%%% Calculating the radii depending on the new center line.
[distances] = pdist2(CLb,SurfPointsvect,'minkowski',2,'Smallest',1); 
radius = double(reshape(distances(1,:), sizes(1), sizes(2)));

